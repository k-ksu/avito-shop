package mocks

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

//go:generate minimock -i github.com/k-ksu/avito-shop/internal/service.ShopHistoryRepo -o ./internal/service/mocks/shop_history_repo.go -n ShopHistoryRepo

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	"github.com/k-ksu/avito-shop/internal/model"
	"github.com/k-ksu/avito-shop/internal/repository/wrapper"
)

// ShopHistoryRepo implements service.ShopHistoryRepo
type ShopHistoryRepo struct {
	t minimock.Tester

	funcAddNew          func(ctx context.Context, tx wrapper.Tx, shopHistory model.ShopHistory) (err error)
	inspectFuncAddNew   func(ctx context.Context, tx wrapper.Tx, shopHistory model.ShopHistory)
	afterAddNewCounter  uint64
	beforeAddNewCounter uint64
	AddNewMock          mShopHistoryRepoAddNew

	funcGetAllByUser          func(ctx context.Context, tx wrapper.Tx, id int64) (ia1 []model.Inventory, err error)
	inspectFuncGetAllByUser   func(ctx context.Context, tx wrapper.Tx, id int64)
	afterGetAllByUserCounter  uint64
	beforeGetAllByUserCounter uint64
	GetAllByUserMock          mShopHistoryRepoGetAllByUser
}

// NewShopHistoryRepo returns a mock for service.ShopHistoryRepo
func NewShopHistoryRepo(t minimock.Tester) *ShopHistoryRepo {
	m := &ShopHistoryRepo{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.AddNewMock = mShopHistoryRepoAddNew{mock: m}
	m.AddNewMock.callArgs = []*ShopHistoryRepoAddNewParams{}

	m.GetAllByUserMock = mShopHistoryRepoGetAllByUser{mock: m}
	m.GetAllByUserMock.callArgs = []*ShopHistoryRepoGetAllByUserParams{}

	return m
}

type mShopHistoryRepoAddNew struct {
	mock               *ShopHistoryRepo
	defaultExpectation *ShopHistoryRepoAddNewExpectation
	expectations       []*ShopHistoryRepoAddNewExpectation

	callArgs []*ShopHistoryRepoAddNewParams
	mutex    sync.RWMutex
}

// ShopHistoryRepoAddNewExpectation specifies expectation struct of the ShopHistoryRepo.AddNew
type ShopHistoryRepoAddNewExpectation struct {
	mock    *ShopHistoryRepo
	params  *ShopHistoryRepoAddNewParams
	results *ShopHistoryRepoAddNewResults
	Counter uint64
}

// ShopHistoryRepoAddNewParams contains parameters of the ShopHistoryRepo.AddNew
type ShopHistoryRepoAddNewParams struct {
	ctx         context.Context
	tx          wrapper.Tx
	shopHistory model.ShopHistory
}

// ShopHistoryRepoAddNewResults contains results of the ShopHistoryRepo.AddNew
type ShopHistoryRepoAddNewResults struct {
	err error
}

// Expect sets up expected params for ShopHistoryRepo.AddNew
func (mmAddNew *mShopHistoryRepoAddNew) Expect(ctx context.Context, tx wrapper.Tx, shopHistory model.ShopHistory) *mShopHistoryRepoAddNew {
	if mmAddNew.mock.funcAddNew != nil {
		mmAddNew.mock.t.Fatalf("ShopHistoryRepo.AddNew mock is already set by Set")
	}

	if mmAddNew.defaultExpectation == nil {
		mmAddNew.defaultExpectation = &ShopHistoryRepoAddNewExpectation{}
	}

	mmAddNew.defaultExpectation.params = &ShopHistoryRepoAddNewParams{ctx, tx, shopHistory}
	for _, e := range mmAddNew.expectations {
		if minimock.Equal(e.params, mmAddNew.defaultExpectation.params) {
			mmAddNew.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmAddNew.defaultExpectation.params)
		}
	}

	return mmAddNew
}

// Inspect accepts an inspector function that has same arguments as the ShopHistoryRepo.AddNew
func (mmAddNew *mShopHistoryRepoAddNew) Inspect(f func(ctx context.Context, tx wrapper.Tx, shopHistory model.ShopHistory)) *mShopHistoryRepoAddNew {
	if mmAddNew.mock.inspectFuncAddNew != nil {
		mmAddNew.mock.t.Fatalf("Inspect function is already set for ShopHistoryRepo.AddNew")
	}

	mmAddNew.mock.inspectFuncAddNew = f

	return mmAddNew
}

// Return sets up results that will be returned by ShopHistoryRepo.AddNew
func (mmAddNew *mShopHistoryRepoAddNew) Return(err error) *ShopHistoryRepo {
	if mmAddNew.mock.funcAddNew != nil {
		mmAddNew.mock.t.Fatalf("ShopHistoryRepo.AddNew mock is already set by Set")
	}

	if mmAddNew.defaultExpectation == nil {
		mmAddNew.defaultExpectation = &ShopHistoryRepoAddNewExpectation{mock: mmAddNew.mock}
	}
	mmAddNew.defaultExpectation.results = &ShopHistoryRepoAddNewResults{err}
	return mmAddNew.mock
}

// Set uses given function f to mock the ShopHistoryRepo.AddNew method
func (mmAddNew *mShopHistoryRepoAddNew) Set(f func(ctx context.Context, tx wrapper.Tx, shopHistory model.ShopHistory) (err error)) *ShopHistoryRepo {
	if mmAddNew.defaultExpectation != nil {
		mmAddNew.mock.t.Fatalf("Default expectation is already set for the ShopHistoryRepo.AddNew method")
	}

	if len(mmAddNew.expectations) > 0 {
		mmAddNew.mock.t.Fatalf("Some expectations are already set for the ShopHistoryRepo.AddNew method")
	}

	mmAddNew.mock.funcAddNew = f
	return mmAddNew.mock
}

// When sets expectation for the ShopHistoryRepo.AddNew which will trigger the result defined by the following
// Then helper
func (mmAddNew *mShopHistoryRepoAddNew) When(ctx context.Context, tx wrapper.Tx, shopHistory model.ShopHistory) *ShopHistoryRepoAddNewExpectation {
	if mmAddNew.mock.funcAddNew != nil {
		mmAddNew.mock.t.Fatalf("ShopHistoryRepo.AddNew mock is already set by Set")
	}

	expectation := &ShopHistoryRepoAddNewExpectation{
		mock:   mmAddNew.mock,
		params: &ShopHistoryRepoAddNewParams{ctx, tx, shopHistory},
	}
	mmAddNew.expectations = append(mmAddNew.expectations, expectation)
	return expectation
}

// Then sets up ShopHistoryRepo.AddNew return parameters for the expectation previously defined by the When method
func (e *ShopHistoryRepoAddNewExpectation) Then(err error) *ShopHistoryRepo {
	e.results = &ShopHistoryRepoAddNewResults{err}
	return e.mock
}

// AddNew implements service.ShopHistoryRepo
func (mmAddNew *ShopHistoryRepo) AddNew(ctx context.Context, tx wrapper.Tx, shopHistory model.ShopHistory) (err error) {
	mm_atomic.AddUint64(&mmAddNew.beforeAddNewCounter, 1)
	defer mm_atomic.AddUint64(&mmAddNew.afterAddNewCounter, 1)

	if mmAddNew.inspectFuncAddNew != nil {
		mmAddNew.inspectFuncAddNew(ctx, tx, shopHistory)
	}

	mm_params := &ShopHistoryRepoAddNewParams{ctx, tx, shopHistory}

	// Record call args
	mmAddNew.AddNewMock.mutex.Lock()
	mmAddNew.AddNewMock.callArgs = append(mmAddNew.AddNewMock.callArgs, mm_params)
	mmAddNew.AddNewMock.mutex.Unlock()

	for _, e := range mmAddNew.AddNewMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmAddNew.AddNewMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAddNew.AddNewMock.defaultExpectation.Counter, 1)
		mm_want := mmAddNew.AddNewMock.defaultExpectation.params
		mm_got := ShopHistoryRepoAddNewParams{ctx, tx, shopHistory}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmAddNew.t.Errorf("ShopHistoryRepo.AddNew got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmAddNew.AddNewMock.defaultExpectation.results
		if mm_results == nil {
			mmAddNew.t.Fatal("No results are set for the ShopHistoryRepo.AddNew")
		}
		return (*mm_results).err
	}
	if mmAddNew.funcAddNew != nil {
		return mmAddNew.funcAddNew(ctx, tx, shopHistory)
	}
	mmAddNew.t.Fatalf("Unexpected call to ShopHistoryRepo.AddNew. %v %v %v", ctx, tx, shopHistory)
	return
}

// AddNewAfterCounter returns a count of finished ShopHistoryRepo.AddNew invocations
func (mmAddNew *ShopHistoryRepo) AddNewAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddNew.afterAddNewCounter)
}

// AddNewBeforeCounter returns a count of ShopHistoryRepo.AddNew invocations
func (mmAddNew *ShopHistoryRepo) AddNewBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddNew.beforeAddNewCounter)
}

// Calls returns a list of arguments used in each call to ShopHistoryRepo.AddNew.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmAddNew *mShopHistoryRepoAddNew) Calls() []*ShopHistoryRepoAddNewParams {
	mmAddNew.mutex.RLock()

	argCopy := make([]*ShopHistoryRepoAddNewParams, len(mmAddNew.callArgs))
	copy(argCopy, mmAddNew.callArgs)

	mmAddNew.mutex.RUnlock()

	return argCopy
}

// MinimockAddNewDone returns true if the count of the AddNew invocations corresponds
// the number of defined expectations
func (m *ShopHistoryRepo) MinimockAddNewDone() bool {
	for _, e := range m.AddNewMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.AddNewMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterAddNewCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAddNew != nil && mm_atomic.LoadUint64(&m.afterAddNewCounter) < 1 {
		return false
	}
	return true
}

// MinimockAddNewInspect logs each unmet expectation
func (m *ShopHistoryRepo) MinimockAddNewInspect() {
	for _, e := range m.AddNewMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ShopHistoryRepo.AddNew with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.AddNewMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterAddNewCounter) < 1 {
		if m.AddNewMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ShopHistoryRepo.AddNew")
		} else {
			m.t.Errorf("Expected call to ShopHistoryRepo.AddNew with params: %#v", *m.AddNewMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAddNew != nil && mm_atomic.LoadUint64(&m.afterAddNewCounter) < 1 {
		m.t.Error("Expected call to ShopHistoryRepo.AddNew")
	}
}

type mShopHistoryRepoGetAllByUser struct {
	mock               *ShopHistoryRepo
	defaultExpectation *ShopHistoryRepoGetAllByUserExpectation
	expectations       []*ShopHistoryRepoGetAllByUserExpectation

	callArgs []*ShopHistoryRepoGetAllByUserParams
	mutex    sync.RWMutex
}

// ShopHistoryRepoGetAllByUserExpectation specifies expectation struct of the ShopHistoryRepo.GetAllByUser
type ShopHistoryRepoGetAllByUserExpectation struct {
	mock    *ShopHistoryRepo
	params  *ShopHistoryRepoGetAllByUserParams
	results *ShopHistoryRepoGetAllByUserResults
	Counter uint64
}

// ShopHistoryRepoGetAllByUserParams contains parameters of the ShopHistoryRepo.GetAllByUser
type ShopHistoryRepoGetAllByUserParams struct {
	ctx context.Context
	tx  wrapper.Tx
	id  int64
}

// ShopHistoryRepoGetAllByUserResults contains results of the ShopHistoryRepo.GetAllByUser
type ShopHistoryRepoGetAllByUserResults struct {
	ia1 []model.Inventory
	err error
}

// Expect sets up expected params for ShopHistoryRepo.GetAllByUser
func (mmGetAllByUser *mShopHistoryRepoGetAllByUser) Expect(ctx context.Context, tx wrapper.Tx, id int64) *mShopHistoryRepoGetAllByUser {
	if mmGetAllByUser.mock.funcGetAllByUser != nil {
		mmGetAllByUser.mock.t.Fatalf("ShopHistoryRepo.GetAllByUser mock is already set by Set")
	}

	if mmGetAllByUser.defaultExpectation == nil {
		mmGetAllByUser.defaultExpectation = &ShopHistoryRepoGetAllByUserExpectation{}
	}

	mmGetAllByUser.defaultExpectation.params = &ShopHistoryRepoGetAllByUserParams{ctx, tx, id}
	for _, e := range mmGetAllByUser.expectations {
		if minimock.Equal(e.params, mmGetAllByUser.defaultExpectation.params) {
			mmGetAllByUser.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetAllByUser.defaultExpectation.params)
		}
	}

	return mmGetAllByUser
}

// Inspect accepts an inspector function that has same arguments as the ShopHistoryRepo.GetAllByUser
func (mmGetAllByUser *mShopHistoryRepoGetAllByUser) Inspect(f func(ctx context.Context, tx wrapper.Tx, id int64)) *mShopHistoryRepoGetAllByUser {
	if mmGetAllByUser.mock.inspectFuncGetAllByUser != nil {
		mmGetAllByUser.mock.t.Fatalf("Inspect function is already set for ShopHistoryRepo.GetAllByUser")
	}

	mmGetAllByUser.mock.inspectFuncGetAllByUser = f

	return mmGetAllByUser
}

// Return sets up results that will be returned by ShopHistoryRepo.GetAllByUser
func (mmGetAllByUser *mShopHistoryRepoGetAllByUser) Return(ia1 []model.Inventory, err error) *ShopHistoryRepo {
	if mmGetAllByUser.mock.funcGetAllByUser != nil {
		mmGetAllByUser.mock.t.Fatalf("ShopHistoryRepo.GetAllByUser mock is already set by Set")
	}

	if mmGetAllByUser.defaultExpectation == nil {
		mmGetAllByUser.defaultExpectation = &ShopHistoryRepoGetAllByUserExpectation{mock: mmGetAllByUser.mock}
	}
	mmGetAllByUser.defaultExpectation.results = &ShopHistoryRepoGetAllByUserResults{ia1, err}
	return mmGetAllByUser.mock
}

// Set uses given function f to mock the ShopHistoryRepo.GetAllByUser method
func (mmGetAllByUser *mShopHistoryRepoGetAllByUser) Set(f func(ctx context.Context, tx wrapper.Tx, id int64) (ia1 []model.Inventory, err error)) *ShopHistoryRepo {
	if mmGetAllByUser.defaultExpectation != nil {
		mmGetAllByUser.mock.t.Fatalf("Default expectation is already set for the ShopHistoryRepo.GetAllByUser method")
	}

	if len(mmGetAllByUser.expectations) > 0 {
		mmGetAllByUser.mock.t.Fatalf("Some expectations are already set for the ShopHistoryRepo.GetAllByUser method")
	}

	mmGetAllByUser.mock.funcGetAllByUser = f
	return mmGetAllByUser.mock
}

// When sets expectation for the ShopHistoryRepo.GetAllByUser which will trigger the result defined by the following
// Then helper
func (mmGetAllByUser *mShopHistoryRepoGetAllByUser) When(ctx context.Context, tx wrapper.Tx, id int64) *ShopHistoryRepoGetAllByUserExpectation {
	if mmGetAllByUser.mock.funcGetAllByUser != nil {
		mmGetAllByUser.mock.t.Fatalf("ShopHistoryRepo.GetAllByUser mock is already set by Set")
	}

	expectation := &ShopHistoryRepoGetAllByUserExpectation{
		mock:   mmGetAllByUser.mock,
		params: &ShopHistoryRepoGetAllByUserParams{ctx, tx, id},
	}
	mmGetAllByUser.expectations = append(mmGetAllByUser.expectations, expectation)
	return expectation
}

// Then sets up ShopHistoryRepo.GetAllByUser return parameters for the expectation previously defined by the When method
func (e *ShopHistoryRepoGetAllByUserExpectation) Then(ia1 []model.Inventory, err error) *ShopHistoryRepo {
	e.results = &ShopHistoryRepoGetAllByUserResults{ia1, err}
	return e.mock
}

// GetAllByUser implements service.ShopHistoryRepo
func (mmGetAllByUser *ShopHistoryRepo) GetAllByUser(ctx context.Context, tx wrapper.Tx, id int64) (ia1 []model.Inventory, err error) {
	mm_atomic.AddUint64(&mmGetAllByUser.beforeGetAllByUserCounter, 1)
	defer mm_atomic.AddUint64(&mmGetAllByUser.afterGetAllByUserCounter, 1)

	if mmGetAllByUser.inspectFuncGetAllByUser != nil {
		mmGetAllByUser.inspectFuncGetAllByUser(ctx, tx, id)
	}

	mm_params := &ShopHistoryRepoGetAllByUserParams{ctx, tx, id}

	// Record call args
	mmGetAllByUser.GetAllByUserMock.mutex.Lock()
	mmGetAllByUser.GetAllByUserMock.callArgs = append(mmGetAllByUser.GetAllByUserMock.callArgs, mm_params)
	mmGetAllByUser.GetAllByUserMock.mutex.Unlock()

	for _, e := range mmGetAllByUser.GetAllByUserMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ia1, e.results.err
		}
	}

	if mmGetAllByUser.GetAllByUserMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetAllByUser.GetAllByUserMock.defaultExpectation.Counter, 1)
		mm_want := mmGetAllByUser.GetAllByUserMock.defaultExpectation.params
		mm_got := ShopHistoryRepoGetAllByUserParams{ctx, tx, id}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetAllByUser.t.Errorf("ShopHistoryRepo.GetAllByUser got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetAllByUser.GetAllByUserMock.defaultExpectation.results
		if mm_results == nil {
			mmGetAllByUser.t.Fatal("No results are set for the ShopHistoryRepo.GetAllByUser")
		}
		return (*mm_results).ia1, (*mm_results).err
	}
	if mmGetAllByUser.funcGetAllByUser != nil {
		return mmGetAllByUser.funcGetAllByUser(ctx, tx, id)
	}
	mmGetAllByUser.t.Fatalf("Unexpected call to ShopHistoryRepo.GetAllByUser. %v %v %v", ctx, tx, id)
	return
}

// GetAllByUserAfterCounter returns a count of finished ShopHistoryRepo.GetAllByUser invocations
func (mmGetAllByUser *ShopHistoryRepo) GetAllByUserAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetAllByUser.afterGetAllByUserCounter)
}

// GetAllByUserBeforeCounter returns a count of ShopHistoryRepo.GetAllByUser invocations
func (mmGetAllByUser *ShopHistoryRepo) GetAllByUserBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetAllByUser.beforeGetAllByUserCounter)
}

// Calls returns a list of arguments used in each call to ShopHistoryRepo.GetAllByUser.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetAllByUser *mShopHistoryRepoGetAllByUser) Calls() []*ShopHistoryRepoGetAllByUserParams {
	mmGetAllByUser.mutex.RLock()

	argCopy := make([]*ShopHistoryRepoGetAllByUserParams, len(mmGetAllByUser.callArgs))
	copy(argCopy, mmGetAllByUser.callArgs)

	mmGetAllByUser.mutex.RUnlock()

	return argCopy
}

// MinimockGetAllByUserDone returns true if the count of the GetAllByUser invocations corresponds
// the number of defined expectations
func (m *ShopHistoryRepo) MinimockGetAllByUserDone() bool {
	for _, e := range m.GetAllByUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetAllByUserMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetAllByUserCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetAllByUser != nil && mm_atomic.LoadUint64(&m.afterGetAllByUserCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetAllByUserInspect logs each unmet expectation
func (m *ShopHistoryRepo) MinimockGetAllByUserInspect() {
	for _, e := range m.GetAllByUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ShopHistoryRepo.GetAllByUser with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetAllByUserMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetAllByUserCounter) < 1 {
		if m.GetAllByUserMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ShopHistoryRepo.GetAllByUser")
		} else {
			m.t.Errorf("Expected call to ShopHistoryRepo.GetAllByUser with params: %#v", *m.GetAllByUserMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetAllByUser != nil && mm_atomic.LoadUint64(&m.afterGetAllByUserCounter) < 1 {
		m.t.Error("Expected call to ShopHistoryRepo.GetAllByUser")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *ShopHistoryRepo) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockAddNewInspect()

		m.MinimockGetAllByUserInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *ShopHistoryRepo) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *ShopHistoryRepo) minimockDone() bool {
	done := true
	return done &&
		m.MinimockAddNewDone() &&
		m.MinimockGetAllByUserDone()
}
