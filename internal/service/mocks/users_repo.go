package mocks

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

//go:generate minimock -i github.com/k-ksu/avito-shop/internal/service.UsersRepo -o ./internal/service/mocks/users_repo.go -n UsersRepo

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	"github.com/k-ksu/avito-shop/internal/model"
	"github.com/k-ksu/avito-shop/internal/repository/wrapper"
)

// UsersRepo implements service.UsersRepo
type UsersRepo struct {
	t minimock.Tester

	funcCreateUser          func(ctx context.Context, name string, pass string) (u1 model.User, err error)
	inspectFuncCreateUser   func(ctx context.Context, name string, pass string)
	afterCreateUserCounter  uint64
	beforeCreateUserCounter uint64
	CreateUserMock          mUsersRepoCreateUser

	funcLockUsers          func(ctx context.Context, tx wrapper.Tx, users []model.User) (err error)
	inspectFuncLockUsers   func(ctx context.Context, tx wrapper.Tx, users []model.User)
	afterLockUsersCounter  uint64
	beforeLockUsersCounter uint64
	LockUsersMock          mUsersRepoLockUsers

	funcUpdateCoins          func(ctx context.Context, tx wrapper.Tx, users []model.User) (err error)
	inspectFuncUpdateCoins   func(ctx context.Context, tx wrapper.Tx, users []model.User)
	afterUpdateCoinsCounter  uint64
	beforeUpdateCoinsCounter uint64
	UpdateCoinsMock          mUsersRepoUpdateCoins

	funcUserByName          func(ctx context.Context, name string) (u1 model.User, err error)
	inspectFuncUserByName   func(ctx context.Context, name string)
	afterUserByNameCounter  uint64
	beforeUserByNameCounter uint64
	UserByNameMock          mUsersRepoUserByName

	funcUsersByNames          func(ctx context.Context, tx wrapper.Tx, names []string) (ua1 []model.User, err error)
	inspectFuncUsersByNames   func(ctx context.Context, tx wrapper.Tx, names []string)
	afterUsersByNamesCounter  uint64
	beforeUsersByNamesCounter uint64
	UsersByNamesMock          mUsersRepoUsersByNames
}

// NewUsersRepo returns a mock for service.UsersRepo
func NewUsersRepo(t minimock.Tester) *UsersRepo {
	m := &UsersRepo{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.CreateUserMock = mUsersRepoCreateUser{mock: m}
	m.CreateUserMock.callArgs = []*UsersRepoCreateUserParams{}

	m.LockUsersMock = mUsersRepoLockUsers{mock: m}
	m.LockUsersMock.callArgs = []*UsersRepoLockUsersParams{}

	m.UpdateCoinsMock = mUsersRepoUpdateCoins{mock: m}
	m.UpdateCoinsMock.callArgs = []*UsersRepoUpdateCoinsParams{}

	m.UserByNameMock = mUsersRepoUserByName{mock: m}
	m.UserByNameMock.callArgs = []*UsersRepoUserByNameParams{}

	m.UsersByNamesMock = mUsersRepoUsersByNames{mock: m}
	m.UsersByNamesMock.callArgs = []*UsersRepoUsersByNamesParams{}

	return m
}

type mUsersRepoCreateUser struct {
	mock               *UsersRepo
	defaultExpectation *UsersRepoCreateUserExpectation
	expectations       []*UsersRepoCreateUserExpectation

	callArgs []*UsersRepoCreateUserParams
	mutex    sync.RWMutex
}

// UsersRepoCreateUserExpectation specifies expectation struct of the UsersRepo.CreateUser
type UsersRepoCreateUserExpectation struct {
	mock    *UsersRepo
	params  *UsersRepoCreateUserParams
	results *UsersRepoCreateUserResults
	Counter uint64
}

// UsersRepoCreateUserParams contains parameters of the UsersRepo.CreateUser
type UsersRepoCreateUserParams struct {
	ctx  context.Context
	name string
	pass string
}

// UsersRepoCreateUserResults contains results of the UsersRepo.CreateUser
type UsersRepoCreateUserResults struct {
	u1  model.User
	err error
}

// Expect sets up expected params for UsersRepo.CreateUser
func (mmCreateUser *mUsersRepoCreateUser) Expect(ctx context.Context, name string, pass string) *mUsersRepoCreateUser {
	if mmCreateUser.mock.funcCreateUser != nil {
		mmCreateUser.mock.t.Fatalf("UsersRepo.CreateUser mock is already set by Set")
	}

	if mmCreateUser.defaultExpectation == nil {
		mmCreateUser.defaultExpectation = &UsersRepoCreateUserExpectation{}
	}

	mmCreateUser.defaultExpectation.params = &UsersRepoCreateUserParams{ctx, name, pass}
	for _, e := range mmCreateUser.expectations {
		if minimock.Equal(e.params, mmCreateUser.defaultExpectation.params) {
			mmCreateUser.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateUser.defaultExpectation.params)
		}
	}

	return mmCreateUser
}

// Inspect accepts an inspector function that has same arguments as the UsersRepo.CreateUser
func (mmCreateUser *mUsersRepoCreateUser) Inspect(f func(ctx context.Context, name string, pass string)) *mUsersRepoCreateUser {
	if mmCreateUser.mock.inspectFuncCreateUser != nil {
		mmCreateUser.mock.t.Fatalf("Inspect function is already set for UsersRepo.CreateUser")
	}

	mmCreateUser.mock.inspectFuncCreateUser = f

	return mmCreateUser
}

// Return sets up results that will be returned by UsersRepo.CreateUser
func (mmCreateUser *mUsersRepoCreateUser) Return(u1 model.User, err error) *UsersRepo {
	if mmCreateUser.mock.funcCreateUser != nil {
		mmCreateUser.mock.t.Fatalf("UsersRepo.CreateUser mock is already set by Set")
	}

	if mmCreateUser.defaultExpectation == nil {
		mmCreateUser.defaultExpectation = &UsersRepoCreateUserExpectation{mock: mmCreateUser.mock}
	}
	mmCreateUser.defaultExpectation.results = &UsersRepoCreateUserResults{u1, err}
	return mmCreateUser.mock
}

// Set uses given function f to mock the UsersRepo.CreateUser method
func (mmCreateUser *mUsersRepoCreateUser) Set(f func(ctx context.Context, name string, pass string) (u1 model.User, err error)) *UsersRepo {
	if mmCreateUser.defaultExpectation != nil {
		mmCreateUser.mock.t.Fatalf("Default expectation is already set for the UsersRepo.CreateUser method")
	}

	if len(mmCreateUser.expectations) > 0 {
		mmCreateUser.mock.t.Fatalf("Some expectations are already set for the UsersRepo.CreateUser method")
	}

	mmCreateUser.mock.funcCreateUser = f
	return mmCreateUser.mock
}

// When sets expectation for the UsersRepo.CreateUser which will trigger the result defined by the following
// Then helper
func (mmCreateUser *mUsersRepoCreateUser) When(ctx context.Context, name string, pass string) *UsersRepoCreateUserExpectation {
	if mmCreateUser.mock.funcCreateUser != nil {
		mmCreateUser.mock.t.Fatalf("UsersRepo.CreateUser mock is already set by Set")
	}

	expectation := &UsersRepoCreateUserExpectation{
		mock:   mmCreateUser.mock,
		params: &UsersRepoCreateUserParams{ctx, name, pass},
	}
	mmCreateUser.expectations = append(mmCreateUser.expectations, expectation)
	return expectation
}

// Then sets up UsersRepo.CreateUser return parameters for the expectation previously defined by the When method
func (e *UsersRepoCreateUserExpectation) Then(u1 model.User, err error) *UsersRepo {
	e.results = &UsersRepoCreateUserResults{u1, err}
	return e.mock
}

// CreateUser implements service.UsersRepo
func (mmCreateUser *UsersRepo) CreateUser(ctx context.Context, name string, pass string) (u1 model.User, err error) {
	mm_atomic.AddUint64(&mmCreateUser.beforeCreateUserCounter, 1)
	defer mm_atomic.AddUint64(&mmCreateUser.afterCreateUserCounter, 1)

	if mmCreateUser.inspectFuncCreateUser != nil {
		mmCreateUser.inspectFuncCreateUser(ctx, name, pass)
	}

	mm_params := &UsersRepoCreateUserParams{ctx, name, pass}

	// Record call args
	mmCreateUser.CreateUserMock.mutex.Lock()
	mmCreateUser.CreateUserMock.callArgs = append(mmCreateUser.CreateUserMock.callArgs, mm_params)
	mmCreateUser.CreateUserMock.mutex.Unlock()

	for _, e := range mmCreateUser.CreateUserMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.u1, e.results.err
		}
	}

	if mmCreateUser.CreateUserMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreateUser.CreateUserMock.defaultExpectation.Counter, 1)
		mm_want := mmCreateUser.CreateUserMock.defaultExpectation.params
		mm_got := UsersRepoCreateUserParams{ctx, name, pass}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreateUser.t.Errorf("UsersRepo.CreateUser got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreateUser.CreateUserMock.defaultExpectation.results
		if mm_results == nil {
			mmCreateUser.t.Fatal("No results are set for the UsersRepo.CreateUser")
		}
		return (*mm_results).u1, (*mm_results).err
	}
	if mmCreateUser.funcCreateUser != nil {
		return mmCreateUser.funcCreateUser(ctx, name, pass)
	}
	mmCreateUser.t.Fatalf("Unexpected call to UsersRepo.CreateUser. %v %v %v", ctx, name, pass)
	return
}

// CreateUserAfterCounter returns a count of finished UsersRepo.CreateUser invocations
func (mmCreateUser *UsersRepo) CreateUserAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateUser.afterCreateUserCounter)
}

// CreateUserBeforeCounter returns a count of UsersRepo.CreateUser invocations
func (mmCreateUser *UsersRepo) CreateUserBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateUser.beforeCreateUserCounter)
}

// Calls returns a list of arguments used in each call to UsersRepo.CreateUser.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateUser *mUsersRepoCreateUser) Calls() []*UsersRepoCreateUserParams {
	mmCreateUser.mutex.RLock()

	argCopy := make([]*UsersRepoCreateUserParams, len(mmCreateUser.callArgs))
	copy(argCopy, mmCreateUser.callArgs)

	mmCreateUser.mutex.RUnlock()

	return argCopy
}

// MinimockCreateUserDone returns true if the count of the CreateUser invocations corresponds
// the number of defined expectations
func (m *UsersRepo) MinimockCreateUserDone() bool {
	for _, e := range m.CreateUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CreateUserMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCreateUserCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateUser != nil && mm_atomic.LoadUint64(&m.afterCreateUserCounter) < 1 {
		return false
	}
	return true
}

// MinimockCreateUserInspect logs each unmet expectation
func (m *UsersRepo) MinimockCreateUserInspect() {
	for _, e := range m.CreateUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to UsersRepo.CreateUser with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CreateUserMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCreateUserCounter) < 1 {
		if m.CreateUserMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to UsersRepo.CreateUser")
		} else {
			m.t.Errorf("Expected call to UsersRepo.CreateUser with params: %#v", *m.CreateUserMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateUser != nil && mm_atomic.LoadUint64(&m.afterCreateUserCounter) < 1 {
		m.t.Error("Expected call to UsersRepo.CreateUser")
	}
}

type mUsersRepoLockUsers struct {
	mock               *UsersRepo
	defaultExpectation *UsersRepoLockUsersExpectation
	expectations       []*UsersRepoLockUsersExpectation

	callArgs []*UsersRepoLockUsersParams
	mutex    sync.RWMutex
}

// UsersRepoLockUsersExpectation specifies expectation struct of the UsersRepo.LockUsers
type UsersRepoLockUsersExpectation struct {
	mock    *UsersRepo
	params  *UsersRepoLockUsersParams
	results *UsersRepoLockUsersResults
	Counter uint64
}

// UsersRepoLockUsersParams contains parameters of the UsersRepo.LockUsers
type UsersRepoLockUsersParams struct {
	ctx   context.Context
	tx    wrapper.Tx
	users []model.User
}

// UsersRepoLockUsersResults contains results of the UsersRepo.LockUsers
type UsersRepoLockUsersResults struct {
	err error
}

// Expect sets up expected params for UsersRepo.LockUsers
func (mmLockUsers *mUsersRepoLockUsers) Expect(ctx context.Context, tx wrapper.Tx, users []model.User) *mUsersRepoLockUsers {
	if mmLockUsers.mock.funcLockUsers != nil {
		mmLockUsers.mock.t.Fatalf("UsersRepo.LockUsers mock is already set by Set")
	}

	if mmLockUsers.defaultExpectation == nil {
		mmLockUsers.defaultExpectation = &UsersRepoLockUsersExpectation{}
	}

	mmLockUsers.defaultExpectation.params = &UsersRepoLockUsersParams{ctx, tx, users}
	for _, e := range mmLockUsers.expectations {
		if minimock.Equal(e.params, mmLockUsers.defaultExpectation.params) {
			mmLockUsers.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmLockUsers.defaultExpectation.params)
		}
	}

	return mmLockUsers
}

// Inspect accepts an inspector function that has same arguments as the UsersRepo.LockUsers
func (mmLockUsers *mUsersRepoLockUsers) Inspect(f func(ctx context.Context, tx wrapper.Tx, users []model.User)) *mUsersRepoLockUsers {
	if mmLockUsers.mock.inspectFuncLockUsers != nil {
		mmLockUsers.mock.t.Fatalf("Inspect function is already set for UsersRepo.LockUsers")
	}

	mmLockUsers.mock.inspectFuncLockUsers = f

	return mmLockUsers
}

// Return sets up results that will be returned by UsersRepo.LockUsers
func (mmLockUsers *mUsersRepoLockUsers) Return(err error) *UsersRepo {
	if mmLockUsers.mock.funcLockUsers != nil {
		mmLockUsers.mock.t.Fatalf("UsersRepo.LockUsers mock is already set by Set")
	}

	if mmLockUsers.defaultExpectation == nil {
		mmLockUsers.defaultExpectation = &UsersRepoLockUsersExpectation{mock: mmLockUsers.mock}
	}
	mmLockUsers.defaultExpectation.results = &UsersRepoLockUsersResults{err}
	return mmLockUsers.mock
}

// Set uses given function f to mock the UsersRepo.LockUsers method
func (mmLockUsers *mUsersRepoLockUsers) Set(f func(ctx context.Context, tx wrapper.Tx, users []model.User) (err error)) *UsersRepo {
	if mmLockUsers.defaultExpectation != nil {
		mmLockUsers.mock.t.Fatalf("Default expectation is already set for the UsersRepo.LockUsers method")
	}

	if len(mmLockUsers.expectations) > 0 {
		mmLockUsers.mock.t.Fatalf("Some expectations are already set for the UsersRepo.LockUsers method")
	}

	mmLockUsers.mock.funcLockUsers = f
	return mmLockUsers.mock
}

// When sets expectation for the UsersRepo.LockUsers which will trigger the result defined by the following
// Then helper
func (mmLockUsers *mUsersRepoLockUsers) When(ctx context.Context, tx wrapper.Tx, users []model.User) *UsersRepoLockUsersExpectation {
	if mmLockUsers.mock.funcLockUsers != nil {
		mmLockUsers.mock.t.Fatalf("UsersRepo.LockUsers mock is already set by Set")
	}

	expectation := &UsersRepoLockUsersExpectation{
		mock:   mmLockUsers.mock,
		params: &UsersRepoLockUsersParams{ctx, tx, users},
	}
	mmLockUsers.expectations = append(mmLockUsers.expectations, expectation)
	return expectation
}

// Then sets up UsersRepo.LockUsers return parameters for the expectation previously defined by the When method
func (e *UsersRepoLockUsersExpectation) Then(err error) *UsersRepo {
	e.results = &UsersRepoLockUsersResults{err}
	return e.mock
}

// LockUsers implements service.UsersRepo
func (mmLockUsers *UsersRepo) LockUsers(ctx context.Context, tx wrapper.Tx, users []model.User) (err error) {
	mm_atomic.AddUint64(&mmLockUsers.beforeLockUsersCounter, 1)
	defer mm_atomic.AddUint64(&mmLockUsers.afterLockUsersCounter, 1)

	if mmLockUsers.inspectFuncLockUsers != nil {
		mmLockUsers.inspectFuncLockUsers(ctx, tx, users)
	}

	mm_params := &UsersRepoLockUsersParams{ctx, tx, users}

	// Record call args
	mmLockUsers.LockUsersMock.mutex.Lock()
	mmLockUsers.LockUsersMock.callArgs = append(mmLockUsers.LockUsersMock.callArgs, mm_params)
	mmLockUsers.LockUsersMock.mutex.Unlock()

	for _, e := range mmLockUsers.LockUsersMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmLockUsers.LockUsersMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmLockUsers.LockUsersMock.defaultExpectation.Counter, 1)
		mm_want := mmLockUsers.LockUsersMock.defaultExpectation.params
		mm_got := UsersRepoLockUsersParams{ctx, tx, users}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmLockUsers.t.Errorf("UsersRepo.LockUsers got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmLockUsers.LockUsersMock.defaultExpectation.results
		if mm_results == nil {
			mmLockUsers.t.Fatal("No results are set for the UsersRepo.LockUsers")
		}
		return (*mm_results).err
	}
	if mmLockUsers.funcLockUsers != nil {
		return mmLockUsers.funcLockUsers(ctx, tx, users)
	}
	mmLockUsers.t.Fatalf("Unexpected call to UsersRepo.LockUsers. %v %v %v", ctx, tx, users)
	return
}

// LockUsersAfterCounter returns a count of finished UsersRepo.LockUsers invocations
func (mmLockUsers *UsersRepo) LockUsersAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmLockUsers.afterLockUsersCounter)
}

// LockUsersBeforeCounter returns a count of UsersRepo.LockUsers invocations
func (mmLockUsers *UsersRepo) LockUsersBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmLockUsers.beforeLockUsersCounter)
}

// Calls returns a list of arguments used in each call to UsersRepo.LockUsers.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmLockUsers *mUsersRepoLockUsers) Calls() []*UsersRepoLockUsersParams {
	mmLockUsers.mutex.RLock()

	argCopy := make([]*UsersRepoLockUsersParams, len(mmLockUsers.callArgs))
	copy(argCopy, mmLockUsers.callArgs)

	mmLockUsers.mutex.RUnlock()

	return argCopy
}

// MinimockLockUsersDone returns true if the count of the LockUsers invocations corresponds
// the number of defined expectations
func (m *UsersRepo) MinimockLockUsersDone() bool {
	for _, e := range m.LockUsersMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.LockUsersMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterLockUsersCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcLockUsers != nil && mm_atomic.LoadUint64(&m.afterLockUsersCounter) < 1 {
		return false
	}
	return true
}

// MinimockLockUsersInspect logs each unmet expectation
func (m *UsersRepo) MinimockLockUsersInspect() {
	for _, e := range m.LockUsersMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to UsersRepo.LockUsers with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.LockUsersMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterLockUsersCounter) < 1 {
		if m.LockUsersMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to UsersRepo.LockUsers")
		} else {
			m.t.Errorf("Expected call to UsersRepo.LockUsers with params: %#v", *m.LockUsersMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcLockUsers != nil && mm_atomic.LoadUint64(&m.afterLockUsersCounter) < 1 {
		m.t.Error("Expected call to UsersRepo.LockUsers")
	}
}

type mUsersRepoUpdateCoins struct {
	mock               *UsersRepo
	defaultExpectation *UsersRepoUpdateCoinsExpectation
	expectations       []*UsersRepoUpdateCoinsExpectation

	callArgs []*UsersRepoUpdateCoinsParams
	mutex    sync.RWMutex
}

// UsersRepoUpdateCoinsExpectation specifies expectation struct of the UsersRepo.UpdateCoins
type UsersRepoUpdateCoinsExpectation struct {
	mock    *UsersRepo
	params  *UsersRepoUpdateCoinsParams
	results *UsersRepoUpdateCoinsResults
	Counter uint64
}

// UsersRepoUpdateCoinsParams contains parameters of the UsersRepo.UpdateCoins
type UsersRepoUpdateCoinsParams struct {
	ctx   context.Context
	tx    wrapper.Tx
	users []model.User
}

// UsersRepoUpdateCoinsResults contains results of the UsersRepo.UpdateCoins
type UsersRepoUpdateCoinsResults struct {
	err error
}

// Expect sets up expected params for UsersRepo.UpdateCoins
func (mmUpdateCoins *mUsersRepoUpdateCoins) Expect(ctx context.Context, tx wrapper.Tx, users []model.User) *mUsersRepoUpdateCoins {
	if mmUpdateCoins.mock.funcUpdateCoins != nil {
		mmUpdateCoins.mock.t.Fatalf("UsersRepo.UpdateCoins mock is already set by Set")
	}

	if mmUpdateCoins.defaultExpectation == nil {
		mmUpdateCoins.defaultExpectation = &UsersRepoUpdateCoinsExpectation{}
	}

	mmUpdateCoins.defaultExpectation.params = &UsersRepoUpdateCoinsParams{ctx, tx, users}
	for _, e := range mmUpdateCoins.expectations {
		if minimock.Equal(e.params, mmUpdateCoins.defaultExpectation.params) {
			mmUpdateCoins.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdateCoins.defaultExpectation.params)
		}
	}

	return mmUpdateCoins
}

// Inspect accepts an inspector function that has same arguments as the UsersRepo.UpdateCoins
func (mmUpdateCoins *mUsersRepoUpdateCoins) Inspect(f func(ctx context.Context, tx wrapper.Tx, users []model.User)) *mUsersRepoUpdateCoins {
	if mmUpdateCoins.mock.inspectFuncUpdateCoins != nil {
		mmUpdateCoins.mock.t.Fatalf("Inspect function is already set for UsersRepo.UpdateCoins")
	}

	mmUpdateCoins.mock.inspectFuncUpdateCoins = f

	return mmUpdateCoins
}

// Return sets up results that will be returned by UsersRepo.UpdateCoins
func (mmUpdateCoins *mUsersRepoUpdateCoins) Return(err error) *UsersRepo {
	if mmUpdateCoins.mock.funcUpdateCoins != nil {
		mmUpdateCoins.mock.t.Fatalf("UsersRepo.UpdateCoins mock is already set by Set")
	}

	if mmUpdateCoins.defaultExpectation == nil {
		mmUpdateCoins.defaultExpectation = &UsersRepoUpdateCoinsExpectation{mock: mmUpdateCoins.mock}
	}
	mmUpdateCoins.defaultExpectation.results = &UsersRepoUpdateCoinsResults{err}
	return mmUpdateCoins.mock
}

// Set uses given function f to mock the UsersRepo.UpdateCoins method
func (mmUpdateCoins *mUsersRepoUpdateCoins) Set(f func(ctx context.Context, tx wrapper.Tx, users []model.User) (err error)) *UsersRepo {
	if mmUpdateCoins.defaultExpectation != nil {
		mmUpdateCoins.mock.t.Fatalf("Default expectation is already set for the UsersRepo.UpdateCoins method")
	}

	if len(mmUpdateCoins.expectations) > 0 {
		mmUpdateCoins.mock.t.Fatalf("Some expectations are already set for the UsersRepo.UpdateCoins method")
	}

	mmUpdateCoins.mock.funcUpdateCoins = f
	return mmUpdateCoins.mock
}

// When sets expectation for the UsersRepo.UpdateCoins which will trigger the result defined by the following
// Then helper
func (mmUpdateCoins *mUsersRepoUpdateCoins) When(ctx context.Context, tx wrapper.Tx, users []model.User) *UsersRepoUpdateCoinsExpectation {
	if mmUpdateCoins.mock.funcUpdateCoins != nil {
		mmUpdateCoins.mock.t.Fatalf("UsersRepo.UpdateCoins mock is already set by Set")
	}

	expectation := &UsersRepoUpdateCoinsExpectation{
		mock:   mmUpdateCoins.mock,
		params: &UsersRepoUpdateCoinsParams{ctx, tx, users},
	}
	mmUpdateCoins.expectations = append(mmUpdateCoins.expectations, expectation)
	return expectation
}

// Then sets up UsersRepo.UpdateCoins return parameters for the expectation previously defined by the When method
func (e *UsersRepoUpdateCoinsExpectation) Then(err error) *UsersRepo {
	e.results = &UsersRepoUpdateCoinsResults{err}
	return e.mock
}

// UpdateCoins implements service.UsersRepo
func (mmUpdateCoins *UsersRepo) UpdateCoins(ctx context.Context, tx wrapper.Tx, users []model.User) (err error) {
	mm_atomic.AddUint64(&mmUpdateCoins.beforeUpdateCoinsCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdateCoins.afterUpdateCoinsCounter, 1)

	if mmUpdateCoins.inspectFuncUpdateCoins != nil {
		mmUpdateCoins.inspectFuncUpdateCoins(ctx, tx, users)
	}

	mm_params := &UsersRepoUpdateCoinsParams{ctx, tx, users}

	// Record call args
	mmUpdateCoins.UpdateCoinsMock.mutex.Lock()
	mmUpdateCoins.UpdateCoinsMock.callArgs = append(mmUpdateCoins.UpdateCoinsMock.callArgs, mm_params)
	mmUpdateCoins.UpdateCoinsMock.mutex.Unlock()

	for _, e := range mmUpdateCoins.UpdateCoinsMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmUpdateCoins.UpdateCoinsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdateCoins.UpdateCoinsMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdateCoins.UpdateCoinsMock.defaultExpectation.params
		mm_got := UsersRepoUpdateCoinsParams{ctx, tx, users}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdateCoins.t.Errorf("UsersRepo.UpdateCoins got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdateCoins.UpdateCoinsMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdateCoins.t.Fatal("No results are set for the UsersRepo.UpdateCoins")
		}
		return (*mm_results).err
	}
	if mmUpdateCoins.funcUpdateCoins != nil {
		return mmUpdateCoins.funcUpdateCoins(ctx, tx, users)
	}
	mmUpdateCoins.t.Fatalf("Unexpected call to UsersRepo.UpdateCoins. %v %v %v", ctx, tx, users)
	return
}

// UpdateCoinsAfterCounter returns a count of finished UsersRepo.UpdateCoins invocations
func (mmUpdateCoins *UsersRepo) UpdateCoinsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateCoins.afterUpdateCoinsCounter)
}

// UpdateCoinsBeforeCounter returns a count of UsersRepo.UpdateCoins invocations
func (mmUpdateCoins *UsersRepo) UpdateCoinsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateCoins.beforeUpdateCoinsCounter)
}

// Calls returns a list of arguments used in each call to UsersRepo.UpdateCoins.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdateCoins *mUsersRepoUpdateCoins) Calls() []*UsersRepoUpdateCoinsParams {
	mmUpdateCoins.mutex.RLock()

	argCopy := make([]*UsersRepoUpdateCoinsParams, len(mmUpdateCoins.callArgs))
	copy(argCopy, mmUpdateCoins.callArgs)

	mmUpdateCoins.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateCoinsDone returns true if the count of the UpdateCoins invocations corresponds
// the number of defined expectations
func (m *UsersRepo) MinimockUpdateCoinsDone() bool {
	for _, e := range m.UpdateCoinsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateCoinsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterUpdateCoinsCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateCoins != nil && mm_atomic.LoadUint64(&m.afterUpdateCoinsCounter) < 1 {
		return false
	}
	return true
}

// MinimockUpdateCoinsInspect logs each unmet expectation
func (m *UsersRepo) MinimockUpdateCoinsInspect() {
	for _, e := range m.UpdateCoinsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to UsersRepo.UpdateCoins with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateCoinsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterUpdateCoinsCounter) < 1 {
		if m.UpdateCoinsMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to UsersRepo.UpdateCoins")
		} else {
			m.t.Errorf("Expected call to UsersRepo.UpdateCoins with params: %#v", *m.UpdateCoinsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateCoins != nil && mm_atomic.LoadUint64(&m.afterUpdateCoinsCounter) < 1 {
		m.t.Error("Expected call to UsersRepo.UpdateCoins")
	}
}

type mUsersRepoUserByName struct {
	mock               *UsersRepo
	defaultExpectation *UsersRepoUserByNameExpectation
	expectations       []*UsersRepoUserByNameExpectation

	callArgs []*UsersRepoUserByNameParams
	mutex    sync.RWMutex
}

// UsersRepoUserByNameExpectation specifies expectation struct of the UsersRepo.UserByName
type UsersRepoUserByNameExpectation struct {
	mock    *UsersRepo
	params  *UsersRepoUserByNameParams
	results *UsersRepoUserByNameResults
	Counter uint64
}

// UsersRepoUserByNameParams contains parameters of the UsersRepo.UserByName
type UsersRepoUserByNameParams struct {
	ctx  context.Context
	name string
}

// UsersRepoUserByNameResults contains results of the UsersRepo.UserByName
type UsersRepoUserByNameResults struct {
	u1  model.User
	err error
}

// Expect sets up expected params for UsersRepo.UserByName
func (mmUserByName *mUsersRepoUserByName) Expect(ctx context.Context, name string) *mUsersRepoUserByName {
	if mmUserByName.mock.funcUserByName != nil {
		mmUserByName.mock.t.Fatalf("UsersRepo.UserByName mock is already set by Set")
	}

	if mmUserByName.defaultExpectation == nil {
		mmUserByName.defaultExpectation = &UsersRepoUserByNameExpectation{}
	}

	mmUserByName.defaultExpectation.params = &UsersRepoUserByNameParams{ctx, name}
	for _, e := range mmUserByName.expectations {
		if minimock.Equal(e.params, mmUserByName.defaultExpectation.params) {
			mmUserByName.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUserByName.defaultExpectation.params)
		}
	}

	return mmUserByName
}

// Inspect accepts an inspector function that has same arguments as the UsersRepo.UserByName
func (mmUserByName *mUsersRepoUserByName) Inspect(f func(ctx context.Context, name string)) *mUsersRepoUserByName {
	if mmUserByName.mock.inspectFuncUserByName != nil {
		mmUserByName.mock.t.Fatalf("Inspect function is already set for UsersRepo.UserByName")
	}

	mmUserByName.mock.inspectFuncUserByName = f

	return mmUserByName
}

// Return sets up results that will be returned by UsersRepo.UserByName
func (mmUserByName *mUsersRepoUserByName) Return(u1 model.User, err error) *UsersRepo {
	if mmUserByName.mock.funcUserByName != nil {
		mmUserByName.mock.t.Fatalf("UsersRepo.UserByName mock is already set by Set")
	}

	if mmUserByName.defaultExpectation == nil {
		mmUserByName.defaultExpectation = &UsersRepoUserByNameExpectation{mock: mmUserByName.mock}
	}
	mmUserByName.defaultExpectation.results = &UsersRepoUserByNameResults{u1, err}
	return mmUserByName.mock
}

// Set uses given function f to mock the UsersRepo.UserByName method
func (mmUserByName *mUsersRepoUserByName) Set(f func(ctx context.Context, name string) (u1 model.User, err error)) *UsersRepo {
	if mmUserByName.defaultExpectation != nil {
		mmUserByName.mock.t.Fatalf("Default expectation is already set for the UsersRepo.UserByName method")
	}

	if len(mmUserByName.expectations) > 0 {
		mmUserByName.mock.t.Fatalf("Some expectations are already set for the UsersRepo.UserByName method")
	}

	mmUserByName.mock.funcUserByName = f
	return mmUserByName.mock
}

// When sets expectation for the UsersRepo.UserByName which will trigger the result defined by the following
// Then helper
func (mmUserByName *mUsersRepoUserByName) When(ctx context.Context, name string) *UsersRepoUserByNameExpectation {
	if mmUserByName.mock.funcUserByName != nil {
		mmUserByName.mock.t.Fatalf("UsersRepo.UserByName mock is already set by Set")
	}

	expectation := &UsersRepoUserByNameExpectation{
		mock:   mmUserByName.mock,
		params: &UsersRepoUserByNameParams{ctx, name},
	}
	mmUserByName.expectations = append(mmUserByName.expectations, expectation)
	return expectation
}

// Then sets up UsersRepo.UserByName return parameters for the expectation previously defined by the When method
func (e *UsersRepoUserByNameExpectation) Then(u1 model.User, err error) *UsersRepo {
	e.results = &UsersRepoUserByNameResults{u1, err}
	return e.mock
}

// UserByName implements service.UsersRepo
func (mmUserByName *UsersRepo) UserByName(ctx context.Context, name string) (u1 model.User, err error) {
	mm_atomic.AddUint64(&mmUserByName.beforeUserByNameCounter, 1)
	defer mm_atomic.AddUint64(&mmUserByName.afterUserByNameCounter, 1)

	if mmUserByName.inspectFuncUserByName != nil {
		mmUserByName.inspectFuncUserByName(ctx, name)
	}

	mm_params := &UsersRepoUserByNameParams{ctx, name}

	// Record call args
	mmUserByName.UserByNameMock.mutex.Lock()
	mmUserByName.UserByNameMock.callArgs = append(mmUserByName.UserByNameMock.callArgs, mm_params)
	mmUserByName.UserByNameMock.mutex.Unlock()

	for _, e := range mmUserByName.UserByNameMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.u1, e.results.err
		}
	}

	if mmUserByName.UserByNameMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUserByName.UserByNameMock.defaultExpectation.Counter, 1)
		mm_want := mmUserByName.UserByNameMock.defaultExpectation.params
		mm_got := UsersRepoUserByNameParams{ctx, name}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUserByName.t.Errorf("UsersRepo.UserByName got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUserByName.UserByNameMock.defaultExpectation.results
		if mm_results == nil {
			mmUserByName.t.Fatal("No results are set for the UsersRepo.UserByName")
		}
		return (*mm_results).u1, (*mm_results).err
	}
	if mmUserByName.funcUserByName != nil {
		return mmUserByName.funcUserByName(ctx, name)
	}
	mmUserByName.t.Fatalf("Unexpected call to UsersRepo.UserByName. %v %v", ctx, name)
	return
}

// UserByNameAfterCounter returns a count of finished UsersRepo.UserByName invocations
func (mmUserByName *UsersRepo) UserByNameAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUserByName.afterUserByNameCounter)
}

// UserByNameBeforeCounter returns a count of UsersRepo.UserByName invocations
func (mmUserByName *UsersRepo) UserByNameBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUserByName.beforeUserByNameCounter)
}

// Calls returns a list of arguments used in each call to UsersRepo.UserByName.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUserByName *mUsersRepoUserByName) Calls() []*UsersRepoUserByNameParams {
	mmUserByName.mutex.RLock()

	argCopy := make([]*UsersRepoUserByNameParams, len(mmUserByName.callArgs))
	copy(argCopy, mmUserByName.callArgs)

	mmUserByName.mutex.RUnlock()

	return argCopy
}

// MinimockUserByNameDone returns true if the count of the UserByName invocations corresponds
// the number of defined expectations
func (m *UsersRepo) MinimockUserByNameDone() bool {
	for _, e := range m.UserByNameMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.UserByNameMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterUserByNameCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUserByName != nil && mm_atomic.LoadUint64(&m.afterUserByNameCounter) < 1 {
		return false
	}
	return true
}

// MinimockUserByNameInspect logs each unmet expectation
func (m *UsersRepo) MinimockUserByNameInspect() {
	for _, e := range m.UserByNameMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to UsersRepo.UserByName with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.UserByNameMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterUserByNameCounter) < 1 {
		if m.UserByNameMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to UsersRepo.UserByName")
		} else {
			m.t.Errorf("Expected call to UsersRepo.UserByName with params: %#v", *m.UserByNameMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUserByName != nil && mm_atomic.LoadUint64(&m.afterUserByNameCounter) < 1 {
		m.t.Error("Expected call to UsersRepo.UserByName")
	}
}

type mUsersRepoUsersByNames struct {
	mock               *UsersRepo
	defaultExpectation *UsersRepoUsersByNamesExpectation
	expectations       []*UsersRepoUsersByNamesExpectation

	callArgs []*UsersRepoUsersByNamesParams
	mutex    sync.RWMutex
}

// UsersRepoUsersByNamesExpectation specifies expectation struct of the UsersRepo.UsersByNames
type UsersRepoUsersByNamesExpectation struct {
	mock    *UsersRepo
	params  *UsersRepoUsersByNamesParams
	results *UsersRepoUsersByNamesResults
	Counter uint64
}

// UsersRepoUsersByNamesParams contains parameters of the UsersRepo.UsersByNames
type UsersRepoUsersByNamesParams struct {
	ctx   context.Context
	tx    wrapper.Tx
	names []string
}

// UsersRepoUsersByNamesResults contains results of the UsersRepo.UsersByNames
type UsersRepoUsersByNamesResults struct {
	ua1 []model.User
	err error
}

// Expect sets up expected params for UsersRepo.UsersByNames
func (mmUsersByNames *mUsersRepoUsersByNames) Expect(ctx context.Context, tx wrapper.Tx, names []string) *mUsersRepoUsersByNames {
	if mmUsersByNames.mock.funcUsersByNames != nil {
		mmUsersByNames.mock.t.Fatalf("UsersRepo.UsersByNames mock is already set by Set")
	}

	if mmUsersByNames.defaultExpectation == nil {
		mmUsersByNames.defaultExpectation = &UsersRepoUsersByNamesExpectation{}
	}

	mmUsersByNames.defaultExpectation.params = &UsersRepoUsersByNamesParams{ctx, tx, names}
	for _, e := range mmUsersByNames.expectations {
		if minimock.Equal(e.params, mmUsersByNames.defaultExpectation.params) {
			mmUsersByNames.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUsersByNames.defaultExpectation.params)
		}
	}

	return mmUsersByNames
}

// Inspect accepts an inspector function that has same arguments as the UsersRepo.UsersByNames
func (mmUsersByNames *mUsersRepoUsersByNames) Inspect(f func(ctx context.Context, tx wrapper.Tx, names []string)) *mUsersRepoUsersByNames {
	if mmUsersByNames.mock.inspectFuncUsersByNames != nil {
		mmUsersByNames.mock.t.Fatalf("Inspect function is already set for UsersRepo.UsersByNames")
	}

	mmUsersByNames.mock.inspectFuncUsersByNames = f

	return mmUsersByNames
}

// Return sets up results that will be returned by UsersRepo.UsersByNames
func (mmUsersByNames *mUsersRepoUsersByNames) Return(ua1 []model.User, err error) *UsersRepo {
	if mmUsersByNames.mock.funcUsersByNames != nil {
		mmUsersByNames.mock.t.Fatalf("UsersRepo.UsersByNames mock is already set by Set")
	}

	if mmUsersByNames.defaultExpectation == nil {
		mmUsersByNames.defaultExpectation = &UsersRepoUsersByNamesExpectation{mock: mmUsersByNames.mock}
	}
	mmUsersByNames.defaultExpectation.results = &UsersRepoUsersByNamesResults{ua1, err}
	return mmUsersByNames.mock
}

// Set uses given function f to mock the UsersRepo.UsersByNames method
func (mmUsersByNames *mUsersRepoUsersByNames) Set(f func(ctx context.Context, tx wrapper.Tx, names []string) (ua1 []model.User, err error)) *UsersRepo {
	if mmUsersByNames.defaultExpectation != nil {
		mmUsersByNames.mock.t.Fatalf("Default expectation is already set for the UsersRepo.UsersByNames method")
	}

	if len(mmUsersByNames.expectations) > 0 {
		mmUsersByNames.mock.t.Fatalf("Some expectations are already set for the UsersRepo.UsersByNames method")
	}

	mmUsersByNames.mock.funcUsersByNames = f
	return mmUsersByNames.mock
}

// When sets expectation for the UsersRepo.UsersByNames which will trigger the result defined by the following
// Then helper
func (mmUsersByNames *mUsersRepoUsersByNames) When(ctx context.Context, tx wrapper.Tx, names []string) *UsersRepoUsersByNamesExpectation {
	if mmUsersByNames.mock.funcUsersByNames != nil {
		mmUsersByNames.mock.t.Fatalf("UsersRepo.UsersByNames mock is already set by Set")
	}

	expectation := &UsersRepoUsersByNamesExpectation{
		mock:   mmUsersByNames.mock,
		params: &UsersRepoUsersByNamesParams{ctx, tx, names},
	}
	mmUsersByNames.expectations = append(mmUsersByNames.expectations, expectation)
	return expectation
}

// Then sets up UsersRepo.UsersByNames return parameters for the expectation previously defined by the When method
func (e *UsersRepoUsersByNamesExpectation) Then(ua1 []model.User, err error) *UsersRepo {
	e.results = &UsersRepoUsersByNamesResults{ua1, err}
	return e.mock
}

// UsersByNames implements service.UsersRepo
func (mmUsersByNames *UsersRepo) UsersByNames(ctx context.Context, tx wrapper.Tx, names []string) (ua1 []model.User, err error) {
	mm_atomic.AddUint64(&mmUsersByNames.beforeUsersByNamesCounter, 1)
	defer mm_atomic.AddUint64(&mmUsersByNames.afterUsersByNamesCounter, 1)

	if mmUsersByNames.inspectFuncUsersByNames != nil {
		mmUsersByNames.inspectFuncUsersByNames(ctx, tx, names)
	}

	mm_params := &UsersRepoUsersByNamesParams{ctx, tx, names}

	// Record call args
	mmUsersByNames.UsersByNamesMock.mutex.Lock()
	mmUsersByNames.UsersByNamesMock.callArgs = append(mmUsersByNames.UsersByNamesMock.callArgs, mm_params)
	mmUsersByNames.UsersByNamesMock.mutex.Unlock()

	for _, e := range mmUsersByNames.UsersByNamesMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ua1, e.results.err
		}
	}

	if mmUsersByNames.UsersByNamesMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUsersByNames.UsersByNamesMock.defaultExpectation.Counter, 1)
		mm_want := mmUsersByNames.UsersByNamesMock.defaultExpectation.params
		mm_got := UsersRepoUsersByNamesParams{ctx, tx, names}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUsersByNames.t.Errorf("UsersRepo.UsersByNames got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUsersByNames.UsersByNamesMock.defaultExpectation.results
		if mm_results == nil {
			mmUsersByNames.t.Fatal("No results are set for the UsersRepo.UsersByNames")
		}
		return (*mm_results).ua1, (*mm_results).err
	}
	if mmUsersByNames.funcUsersByNames != nil {
		return mmUsersByNames.funcUsersByNames(ctx, tx, names)
	}
	mmUsersByNames.t.Fatalf("Unexpected call to UsersRepo.UsersByNames. %v %v %v", ctx, tx, names)
	return
}

// UsersByNamesAfterCounter returns a count of finished UsersRepo.UsersByNames invocations
func (mmUsersByNames *UsersRepo) UsersByNamesAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUsersByNames.afterUsersByNamesCounter)
}

// UsersByNamesBeforeCounter returns a count of UsersRepo.UsersByNames invocations
func (mmUsersByNames *UsersRepo) UsersByNamesBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUsersByNames.beforeUsersByNamesCounter)
}

// Calls returns a list of arguments used in each call to UsersRepo.UsersByNames.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUsersByNames *mUsersRepoUsersByNames) Calls() []*UsersRepoUsersByNamesParams {
	mmUsersByNames.mutex.RLock()

	argCopy := make([]*UsersRepoUsersByNamesParams, len(mmUsersByNames.callArgs))
	copy(argCopy, mmUsersByNames.callArgs)

	mmUsersByNames.mutex.RUnlock()

	return argCopy
}

// MinimockUsersByNamesDone returns true if the count of the UsersByNames invocations corresponds
// the number of defined expectations
func (m *UsersRepo) MinimockUsersByNamesDone() bool {
	for _, e := range m.UsersByNamesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.UsersByNamesMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterUsersByNamesCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUsersByNames != nil && mm_atomic.LoadUint64(&m.afterUsersByNamesCounter) < 1 {
		return false
	}
	return true
}

// MinimockUsersByNamesInspect logs each unmet expectation
func (m *UsersRepo) MinimockUsersByNamesInspect() {
	for _, e := range m.UsersByNamesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to UsersRepo.UsersByNames with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.UsersByNamesMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterUsersByNamesCounter) < 1 {
		if m.UsersByNamesMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to UsersRepo.UsersByNames")
		} else {
			m.t.Errorf("Expected call to UsersRepo.UsersByNames with params: %#v", *m.UsersByNamesMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUsersByNames != nil && mm_atomic.LoadUint64(&m.afterUsersByNamesCounter) < 1 {
		m.t.Error("Expected call to UsersRepo.UsersByNames")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *UsersRepo) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockCreateUserInspect()

		m.MinimockLockUsersInspect()

		m.MinimockUpdateCoinsInspect()

		m.MinimockUserByNameInspect()

		m.MinimockUsersByNamesInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *UsersRepo) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *UsersRepo) minimockDone() bool {
	done := true
	return done &&
		m.MinimockCreateUserDone() &&
		m.MinimockLockUsersDone() &&
		m.MinimockUpdateCoinsDone() &&
		m.MinimockUserByNameDone() &&
		m.MinimockUsersByNamesDone()
}
