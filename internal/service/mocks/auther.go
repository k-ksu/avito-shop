package mocks

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

//go:generate minimock -i github.com/k-ksu/avito-shop/internal/service.Auther -o ./internal/service/mocks/auther.go -n Auther

import (
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	"github.com/k-ksu/avito-shop/internal/model"
)

// Auther implements service.Auther
type Auther struct {
	t minimock.Tester

	funcGenerateToken          func(user model.User) (s1 string, err error)
	inspectFuncGenerateToken   func(user model.User)
	afterGenerateTokenCounter  uint64
	beforeGenerateTokenCounter uint64
	GenerateTokenMock          mAutherGenerateToken

	funcParseToken          func(tokenString string) (c1 model.Claims, err error)
	inspectFuncParseToken   func(tokenString string)
	afterParseTokenCounter  uint64
	beforeParseTokenCounter uint64
	ParseTokenMock          mAutherParseToken
}

// NewAuther returns a mock for service.Auther
func NewAuther(t minimock.Tester) *Auther {
	m := &Auther{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.GenerateTokenMock = mAutherGenerateToken{mock: m}
	m.GenerateTokenMock.callArgs = []*AutherGenerateTokenParams{}

	m.ParseTokenMock = mAutherParseToken{mock: m}
	m.ParseTokenMock.callArgs = []*AutherParseTokenParams{}

	return m
}

type mAutherGenerateToken struct {
	mock               *Auther
	defaultExpectation *AutherGenerateTokenExpectation
	expectations       []*AutherGenerateTokenExpectation

	callArgs []*AutherGenerateTokenParams
	mutex    sync.RWMutex
}

// AutherGenerateTokenExpectation specifies expectation struct of the Auther.GenerateToken
type AutherGenerateTokenExpectation struct {
	mock    *Auther
	params  *AutherGenerateTokenParams
	results *AutherGenerateTokenResults
	Counter uint64
}

// AutherGenerateTokenParams contains parameters of the Auther.GenerateToken
type AutherGenerateTokenParams struct {
	user model.User
}

// AutherGenerateTokenResults contains results of the Auther.GenerateToken
type AutherGenerateTokenResults struct {
	s1  string
	err error
}

// Expect sets up expected params for Auther.GenerateToken
func (mmGenerateToken *mAutherGenerateToken) Expect(user model.User) *mAutherGenerateToken {
	if mmGenerateToken.mock.funcGenerateToken != nil {
		mmGenerateToken.mock.t.Fatalf("Auther.GenerateToken mock is already set by Set")
	}

	if mmGenerateToken.defaultExpectation == nil {
		mmGenerateToken.defaultExpectation = &AutherGenerateTokenExpectation{}
	}

	mmGenerateToken.defaultExpectation.params = &AutherGenerateTokenParams{user}
	for _, e := range mmGenerateToken.expectations {
		if minimock.Equal(e.params, mmGenerateToken.defaultExpectation.params) {
			mmGenerateToken.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGenerateToken.defaultExpectation.params)
		}
	}

	return mmGenerateToken
}

// Inspect accepts an inspector function that has same arguments as the Auther.GenerateToken
func (mmGenerateToken *mAutherGenerateToken) Inspect(f func(user model.User)) *mAutherGenerateToken {
	if mmGenerateToken.mock.inspectFuncGenerateToken != nil {
		mmGenerateToken.mock.t.Fatalf("Inspect function is already set for Auther.GenerateToken")
	}

	mmGenerateToken.mock.inspectFuncGenerateToken = f

	return mmGenerateToken
}

// Return sets up results that will be returned by Auther.GenerateToken
func (mmGenerateToken *mAutherGenerateToken) Return(s1 string, err error) *Auther {
	if mmGenerateToken.mock.funcGenerateToken != nil {
		mmGenerateToken.mock.t.Fatalf("Auther.GenerateToken mock is already set by Set")
	}

	if mmGenerateToken.defaultExpectation == nil {
		mmGenerateToken.defaultExpectation = &AutherGenerateTokenExpectation{mock: mmGenerateToken.mock}
	}
	mmGenerateToken.defaultExpectation.results = &AutherGenerateTokenResults{s1, err}
	return mmGenerateToken.mock
}

// Set uses given function f to mock the Auther.GenerateToken method
func (mmGenerateToken *mAutherGenerateToken) Set(f func(user model.User) (s1 string, err error)) *Auther {
	if mmGenerateToken.defaultExpectation != nil {
		mmGenerateToken.mock.t.Fatalf("Default expectation is already set for the Auther.GenerateToken method")
	}

	if len(mmGenerateToken.expectations) > 0 {
		mmGenerateToken.mock.t.Fatalf("Some expectations are already set for the Auther.GenerateToken method")
	}

	mmGenerateToken.mock.funcGenerateToken = f
	return mmGenerateToken.mock
}

// When sets expectation for the Auther.GenerateToken which will trigger the result defined by the following
// Then helper
func (mmGenerateToken *mAutherGenerateToken) When(user model.User) *AutherGenerateTokenExpectation {
	if mmGenerateToken.mock.funcGenerateToken != nil {
		mmGenerateToken.mock.t.Fatalf("Auther.GenerateToken mock is already set by Set")
	}

	expectation := &AutherGenerateTokenExpectation{
		mock:   mmGenerateToken.mock,
		params: &AutherGenerateTokenParams{user},
	}
	mmGenerateToken.expectations = append(mmGenerateToken.expectations, expectation)
	return expectation
}

// Then sets up Auther.GenerateToken return parameters for the expectation previously defined by the When method
func (e *AutherGenerateTokenExpectation) Then(s1 string, err error) *Auther {
	e.results = &AutherGenerateTokenResults{s1, err}
	return e.mock
}

// GenerateToken implements service.Auther
func (mmGenerateToken *Auther) GenerateToken(user model.User) (s1 string, err error) {
	mm_atomic.AddUint64(&mmGenerateToken.beforeGenerateTokenCounter, 1)
	defer mm_atomic.AddUint64(&mmGenerateToken.afterGenerateTokenCounter, 1)

	if mmGenerateToken.inspectFuncGenerateToken != nil {
		mmGenerateToken.inspectFuncGenerateToken(user)
	}

	mm_params := &AutherGenerateTokenParams{user}

	// Record call args
	mmGenerateToken.GenerateTokenMock.mutex.Lock()
	mmGenerateToken.GenerateTokenMock.callArgs = append(mmGenerateToken.GenerateTokenMock.callArgs, mm_params)
	mmGenerateToken.GenerateTokenMock.mutex.Unlock()

	for _, e := range mmGenerateToken.GenerateTokenMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.s1, e.results.err
		}
	}

	if mmGenerateToken.GenerateTokenMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGenerateToken.GenerateTokenMock.defaultExpectation.Counter, 1)
		mm_want := mmGenerateToken.GenerateTokenMock.defaultExpectation.params
		mm_got := AutherGenerateTokenParams{user}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGenerateToken.t.Errorf("Auther.GenerateToken got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGenerateToken.GenerateTokenMock.defaultExpectation.results
		if mm_results == nil {
			mmGenerateToken.t.Fatal("No results are set for the Auther.GenerateToken")
		}
		return (*mm_results).s1, (*mm_results).err
	}
	if mmGenerateToken.funcGenerateToken != nil {
		return mmGenerateToken.funcGenerateToken(user)
	}
	mmGenerateToken.t.Fatalf("Unexpected call to Auther.GenerateToken. %v", user)
	return
}

// GenerateTokenAfterCounter returns a count of finished Auther.GenerateToken invocations
func (mmGenerateToken *Auther) GenerateTokenAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGenerateToken.afterGenerateTokenCounter)
}

// GenerateTokenBeforeCounter returns a count of Auther.GenerateToken invocations
func (mmGenerateToken *Auther) GenerateTokenBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGenerateToken.beforeGenerateTokenCounter)
}

// Calls returns a list of arguments used in each call to Auther.GenerateToken.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGenerateToken *mAutherGenerateToken) Calls() []*AutherGenerateTokenParams {
	mmGenerateToken.mutex.RLock()

	argCopy := make([]*AutherGenerateTokenParams, len(mmGenerateToken.callArgs))
	copy(argCopy, mmGenerateToken.callArgs)

	mmGenerateToken.mutex.RUnlock()

	return argCopy
}

// MinimockGenerateTokenDone returns true if the count of the GenerateToken invocations corresponds
// the number of defined expectations
func (m *Auther) MinimockGenerateTokenDone() bool {
	for _, e := range m.GenerateTokenMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GenerateTokenMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGenerateTokenCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGenerateToken != nil && mm_atomic.LoadUint64(&m.afterGenerateTokenCounter) < 1 {
		return false
	}
	return true
}

// MinimockGenerateTokenInspect logs each unmet expectation
func (m *Auther) MinimockGenerateTokenInspect() {
	for _, e := range m.GenerateTokenMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to Auther.GenerateToken with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GenerateTokenMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGenerateTokenCounter) < 1 {
		if m.GenerateTokenMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to Auther.GenerateToken")
		} else {
			m.t.Errorf("Expected call to Auther.GenerateToken with params: %#v", *m.GenerateTokenMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGenerateToken != nil && mm_atomic.LoadUint64(&m.afterGenerateTokenCounter) < 1 {
		m.t.Error("Expected call to Auther.GenerateToken")
	}
}

type mAutherParseToken struct {
	mock               *Auther
	defaultExpectation *AutherParseTokenExpectation
	expectations       []*AutherParseTokenExpectation

	callArgs []*AutherParseTokenParams
	mutex    sync.RWMutex
}

// AutherParseTokenExpectation specifies expectation struct of the Auther.ParseToken
type AutherParseTokenExpectation struct {
	mock    *Auther
	params  *AutherParseTokenParams
	results *AutherParseTokenResults
	Counter uint64
}

// AutherParseTokenParams contains parameters of the Auther.ParseToken
type AutherParseTokenParams struct {
	tokenString string
}

// AutherParseTokenResults contains results of the Auther.ParseToken
type AutherParseTokenResults struct {
	c1  model.Claims
	err error
}

// Expect sets up expected params for Auther.ParseToken
func (mmParseToken *mAutherParseToken) Expect(tokenString string) *mAutherParseToken {
	if mmParseToken.mock.funcParseToken != nil {
		mmParseToken.mock.t.Fatalf("Auther.ParseToken mock is already set by Set")
	}

	if mmParseToken.defaultExpectation == nil {
		mmParseToken.defaultExpectation = &AutherParseTokenExpectation{}
	}

	mmParseToken.defaultExpectation.params = &AutherParseTokenParams{tokenString}
	for _, e := range mmParseToken.expectations {
		if minimock.Equal(e.params, mmParseToken.defaultExpectation.params) {
			mmParseToken.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmParseToken.defaultExpectation.params)
		}
	}

	return mmParseToken
}

// Inspect accepts an inspector function that has same arguments as the Auther.ParseToken
func (mmParseToken *mAutherParseToken) Inspect(f func(tokenString string)) *mAutherParseToken {
	if mmParseToken.mock.inspectFuncParseToken != nil {
		mmParseToken.mock.t.Fatalf("Inspect function is already set for Auther.ParseToken")
	}

	mmParseToken.mock.inspectFuncParseToken = f

	return mmParseToken
}

// Return sets up results that will be returned by Auther.ParseToken
func (mmParseToken *mAutherParseToken) Return(c1 model.Claims, err error) *Auther {
	if mmParseToken.mock.funcParseToken != nil {
		mmParseToken.mock.t.Fatalf("Auther.ParseToken mock is already set by Set")
	}

	if mmParseToken.defaultExpectation == nil {
		mmParseToken.defaultExpectation = &AutherParseTokenExpectation{mock: mmParseToken.mock}
	}
	mmParseToken.defaultExpectation.results = &AutherParseTokenResults{c1, err}
	return mmParseToken.mock
}

// Set uses given function f to mock the Auther.ParseToken method
func (mmParseToken *mAutherParseToken) Set(f func(tokenString string) (c1 model.Claims, err error)) *Auther {
	if mmParseToken.defaultExpectation != nil {
		mmParseToken.mock.t.Fatalf("Default expectation is already set for the Auther.ParseToken method")
	}

	if len(mmParseToken.expectations) > 0 {
		mmParseToken.mock.t.Fatalf("Some expectations are already set for the Auther.ParseToken method")
	}

	mmParseToken.mock.funcParseToken = f
	return mmParseToken.mock
}

// When sets expectation for the Auther.ParseToken which will trigger the result defined by the following
// Then helper
func (mmParseToken *mAutherParseToken) When(tokenString string) *AutherParseTokenExpectation {
	if mmParseToken.mock.funcParseToken != nil {
		mmParseToken.mock.t.Fatalf("Auther.ParseToken mock is already set by Set")
	}

	expectation := &AutherParseTokenExpectation{
		mock:   mmParseToken.mock,
		params: &AutherParseTokenParams{tokenString},
	}
	mmParseToken.expectations = append(mmParseToken.expectations, expectation)
	return expectation
}

// Then sets up Auther.ParseToken return parameters for the expectation previously defined by the When method
func (e *AutherParseTokenExpectation) Then(c1 model.Claims, err error) *Auther {
	e.results = &AutherParseTokenResults{c1, err}
	return e.mock
}

// ParseToken implements service.Auther
func (mmParseToken *Auther) ParseToken(tokenString string) (c1 model.Claims, err error) {
	mm_atomic.AddUint64(&mmParseToken.beforeParseTokenCounter, 1)
	defer mm_atomic.AddUint64(&mmParseToken.afterParseTokenCounter, 1)

	if mmParseToken.inspectFuncParseToken != nil {
		mmParseToken.inspectFuncParseToken(tokenString)
	}

	mm_params := &AutherParseTokenParams{tokenString}

	// Record call args
	mmParseToken.ParseTokenMock.mutex.Lock()
	mmParseToken.ParseTokenMock.callArgs = append(mmParseToken.ParseTokenMock.callArgs, mm_params)
	mmParseToken.ParseTokenMock.mutex.Unlock()

	for _, e := range mmParseToken.ParseTokenMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.c1, e.results.err
		}
	}

	if mmParseToken.ParseTokenMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmParseToken.ParseTokenMock.defaultExpectation.Counter, 1)
		mm_want := mmParseToken.ParseTokenMock.defaultExpectation.params
		mm_got := AutherParseTokenParams{tokenString}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmParseToken.t.Errorf("Auther.ParseToken got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmParseToken.ParseTokenMock.defaultExpectation.results
		if mm_results == nil {
			mmParseToken.t.Fatal("No results are set for the Auther.ParseToken")
		}
		return (*mm_results).c1, (*mm_results).err
	}
	if mmParseToken.funcParseToken != nil {
		return mmParseToken.funcParseToken(tokenString)
	}
	mmParseToken.t.Fatalf("Unexpected call to Auther.ParseToken. %v", tokenString)
	return
}

// ParseTokenAfterCounter returns a count of finished Auther.ParseToken invocations
func (mmParseToken *Auther) ParseTokenAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmParseToken.afterParseTokenCounter)
}

// ParseTokenBeforeCounter returns a count of Auther.ParseToken invocations
func (mmParseToken *Auther) ParseTokenBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmParseToken.beforeParseTokenCounter)
}

// Calls returns a list of arguments used in each call to Auther.ParseToken.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmParseToken *mAutherParseToken) Calls() []*AutherParseTokenParams {
	mmParseToken.mutex.RLock()

	argCopy := make([]*AutherParseTokenParams, len(mmParseToken.callArgs))
	copy(argCopy, mmParseToken.callArgs)

	mmParseToken.mutex.RUnlock()

	return argCopy
}

// MinimockParseTokenDone returns true if the count of the ParseToken invocations corresponds
// the number of defined expectations
func (m *Auther) MinimockParseTokenDone() bool {
	for _, e := range m.ParseTokenMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ParseTokenMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterParseTokenCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcParseToken != nil && mm_atomic.LoadUint64(&m.afterParseTokenCounter) < 1 {
		return false
	}
	return true
}

// MinimockParseTokenInspect logs each unmet expectation
func (m *Auther) MinimockParseTokenInspect() {
	for _, e := range m.ParseTokenMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to Auther.ParseToken with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ParseTokenMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterParseTokenCounter) < 1 {
		if m.ParseTokenMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to Auther.ParseToken")
		} else {
			m.t.Errorf("Expected call to Auther.ParseToken with params: %#v", *m.ParseTokenMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcParseToken != nil && mm_atomic.LoadUint64(&m.afterParseTokenCounter) < 1 {
		m.t.Error("Expected call to Auther.ParseToken")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *Auther) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockGenerateTokenInspect()

		m.MinimockParseTokenInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *Auther) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *Auther) minimockDone() bool {
	done := true
	return done &&
		m.MinimockGenerateTokenDone() &&
		m.MinimockParseTokenDone()
}
