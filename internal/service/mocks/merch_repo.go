package mocks

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

//go:generate minimock -i github.com/k-ksu/avito-shop/internal/service.MerchRepo -o ./internal/service/mocks/merch_repo.go -n MerchRepo

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	"github.com/k-ksu/avito-shop/internal/model"
)

// MerchRepo implements service.MerchRepo
type MerchRepo struct {
	t minimock.Tester

	funcGetAllItems          func(ctx context.Context) (ma1 []model.Merch, err error)
	inspectFuncGetAllItems   func(ctx context.Context)
	afterGetAllItemsCounter  uint64
	beforeGetAllItemsCounter uint64
	GetAllItemsMock          mMerchRepoGetAllItems

	funcItemByName          func(ctx context.Context, name string) (m1 model.Merch, err error)
	inspectFuncItemByName   func(ctx context.Context, name string)
	afterItemByNameCounter  uint64
	beforeItemByNameCounter uint64
	ItemByNameMock          mMerchRepoItemByName
}

// NewMerchRepo returns a mock for service.MerchRepo
func NewMerchRepo(t minimock.Tester) *MerchRepo {
	m := &MerchRepo{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.GetAllItemsMock = mMerchRepoGetAllItems{mock: m}
	m.GetAllItemsMock.callArgs = []*MerchRepoGetAllItemsParams{}

	m.ItemByNameMock = mMerchRepoItemByName{mock: m}
	m.ItemByNameMock.callArgs = []*MerchRepoItemByNameParams{}

	return m
}

type mMerchRepoGetAllItems struct {
	mock               *MerchRepo
	defaultExpectation *MerchRepoGetAllItemsExpectation
	expectations       []*MerchRepoGetAllItemsExpectation

	callArgs []*MerchRepoGetAllItemsParams
	mutex    sync.RWMutex
}

// MerchRepoGetAllItemsExpectation specifies expectation struct of the MerchRepo.GetAllItems
type MerchRepoGetAllItemsExpectation struct {
	mock    *MerchRepo
	params  *MerchRepoGetAllItemsParams
	results *MerchRepoGetAllItemsResults
	Counter uint64
}

// MerchRepoGetAllItemsParams contains parameters of the MerchRepo.GetAllItems
type MerchRepoGetAllItemsParams struct {
	ctx context.Context
}

// MerchRepoGetAllItemsResults contains results of the MerchRepo.GetAllItems
type MerchRepoGetAllItemsResults struct {
	ma1 []model.Merch
	err error
}

// Expect sets up expected params for MerchRepo.GetAllItems
func (mmGetAllItems *mMerchRepoGetAllItems) Expect(ctx context.Context) *mMerchRepoGetAllItems {
	if mmGetAllItems.mock.funcGetAllItems != nil {
		mmGetAllItems.mock.t.Fatalf("MerchRepo.GetAllItems mock is already set by Set")
	}

	if mmGetAllItems.defaultExpectation == nil {
		mmGetAllItems.defaultExpectation = &MerchRepoGetAllItemsExpectation{}
	}

	mmGetAllItems.defaultExpectation.params = &MerchRepoGetAllItemsParams{ctx}
	for _, e := range mmGetAllItems.expectations {
		if minimock.Equal(e.params, mmGetAllItems.defaultExpectation.params) {
			mmGetAllItems.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetAllItems.defaultExpectation.params)
		}
	}

	return mmGetAllItems
}

// Inspect accepts an inspector function that has same arguments as the MerchRepo.GetAllItems
func (mmGetAllItems *mMerchRepoGetAllItems) Inspect(f func(ctx context.Context)) *mMerchRepoGetAllItems {
	if mmGetAllItems.mock.inspectFuncGetAllItems != nil {
		mmGetAllItems.mock.t.Fatalf("Inspect function is already set for MerchRepo.GetAllItems")
	}

	mmGetAllItems.mock.inspectFuncGetAllItems = f

	return mmGetAllItems
}

// Return sets up results that will be returned by MerchRepo.GetAllItems
func (mmGetAllItems *mMerchRepoGetAllItems) Return(ma1 []model.Merch, err error) *MerchRepo {
	if mmGetAllItems.mock.funcGetAllItems != nil {
		mmGetAllItems.mock.t.Fatalf("MerchRepo.GetAllItems mock is already set by Set")
	}

	if mmGetAllItems.defaultExpectation == nil {
		mmGetAllItems.defaultExpectation = &MerchRepoGetAllItemsExpectation{mock: mmGetAllItems.mock}
	}
	mmGetAllItems.defaultExpectation.results = &MerchRepoGetAllItemsResults{ma1, err}
	return mmGetAllItems.mock
}

// Set uses given function f to mock the MerchRepo.GetAllItems method
func (mmGetAllItems *mMerchRepoGetAllItems) Set(f func(ctx context.Context) (ma1 []model.Merch, err error)) *MerchRepo {
	if mmGetAllItems.defaultExpectation != nil {
		mmGetAllItems.mock.t.Fatalf("Default expectation is already set for the MerchRepo.GetAllItems method")
	}

	if len(mmGetAllItems.expectations) > 0 {
		mmGetAllItems.mock.t.Fatalf("Some expectations are already set for the MerchRepo.GetAllItems method")
	}

	mmGetAllItems.mock.funcGetAllItems = f
	return mmGetAllItems.mock
}

// When sets expectation for the MerchRepo.GetAllItems which will trigger the result defined by the following
// Then helper
func (mmGetAllItems *mMerchRepoGetAllItems) When(ctx context.Context) *MerchRepoGetAllItemsExpectation {
	if mmGetAllItems.mock.funcGetAllItems != nil {
		mmGetAllItems.mock.t.Fatalf("MerchRepo.GetAllItems mock is already set by Set")
	}

	expectation := &MerchRepoGetAllItemsExpectation{
		mock:   mmGetAllItems.mock,
		params: &MerchRepoGetAllItemsParams{ctx},
	}
	mmGetAllItems.expectations = append(mmGetAllItems.expectations, expectation)
	return expectation
}

// Then sets up MerchRepo.GetAllItems return parameters for the expectation previously defined by the When method
func (e *MerchRepoGetAllItemsExpectation) Then(ma1 []model.Merch, err error) *MerchRepo {
	e.results = &MerchRepoGetAllItemsResults{ma1, err}
	return e.mock
}

// GetAllItems implements service.MerchRepo
func (mmGetAllItems *MerchRepo) GetAllItems(ctx context.Context) (ma1 []model.Merch, err error) {
	mm_atomic.AddUint64(&mmGetAllItems.beforeGetAllItemsCounter, 1)
	defer mm_atomic.AddUint64(&mmGetAllItems.afterGetAllItemsCounter, 1)

	if mmGetAllItems.inspectFuncGetAllItems != nil {
		mmGetAllItems.inspectFuncGetAllItems(ctx)
	}

	mm_params := &MerchRepoGetAllItemsParams{ctx}

	// Record call args
	mmGetAllItems.GetAllItemsMock.mutex.Lock()
	mmGetAllItems.GetAllItemsMock.callArgs = append(mmGetAllItems.GetAllItemsMock.callArgs, mm_params)
	mmGetAllItems.GetAllItemsMock.mutex.Unlock()

	for _, e := range mmGetAllItems.GetAllItemsMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ma1, e.results.err
		}
	}

	if mmGetAllItems.GetAllItemsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetAllItems.GetAllItemsMock.defaultExpectation.Counter, 1)
		mm_want := mmGetAllItems.GetAllItemsMock.defaultExpectation.params
		mm_got := MerchRepoGetAllItemsParams{ctx}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetAllItems.t.Errorf("MerchRepo.GetAllItems got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetAllItems.GetAllItemsMock.defaultExpectation.results
		if mm_results == nil {
			mmGetAllItems.t.Fatal("No results are set for the MerchRepo.GetAllItems")
		}
		return (*mm_results).ma1, (*mm_results).err
	}
	if mmGetAllItems.funcGetAllItems != nil {
		return mmGetAllItems.funcGetAllItems(ctx)
	}
	mmGetAllItems.t.Fatalf("Unexpected call to MerchRepo.GetAllItems. %v", ctx)
	return
}

// GetAllItemsAfterCounter returns a count of finished MerchRepo.GetAllItems invocations
func (mmGetAllItems *MerchRepo) GetAllItemsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetAllItems.afterGetAllItemsCounter)
}

// GetAllItemsBeforeCounter returns a count of MerchRepo.GetAllItems invocations
func (mmGetAllItems *MerchRepo) GetAllItemsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetAllItems.beforeGetAllItemsCounter)
}

// Calls returns a list of arguments used in each call to MerchRepo.GetAllItems.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetAllItems *mMerchRepoGetAllItems) Calls() []*MerchRepoGetAllItemsParams {
	mmGetAllItems.mutex.RLock()

	argCopy := make([]*MerchRepoGetAllItemsParams, len(mmGetAllItems.callArgs))
	copy(argCopy, mmGetAllItems.callArgs)

	mmGetAllItems.mutex.RUnlock()

	return argCopy
}

// MinimockGetAllItemsDone returns true if the count of the GetAllItems invocations corresponds
// the number of defined expectations
func (m *MerchRepo) MinimockGetAllItemsDone() bool {
	for _, e := range m.GetAllItemsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetAllItemsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetAllItemsCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetAllItems != nil && mm_atomic.LoadUint64(&m.afterGetAllItemsCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetAllItemsInspect logs each unmet expectation
func (m *MerchRepo) MinimockGetAllItemsInspect() {
	for _, e := range m.GetAllItemsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to MerchRepo.GetAllItems with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetAllItemsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetAllItemsCounter) < 1 {
		if m.GetAllItemsMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to MerchRepo.GetAllItems")
		} else {
			m.t.Errorf("Expected call to MerchRepo.GetAllItems with params: %#v", *m.GetAllItemsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetAllItems != nil && mm_atomic.LoadUint64(&m.afterGetAllItemsCounter) < 1 {
		m.t.Error("Expected call to MerchRepo.GetAllItems")
	}
}

type mMerchRepoItemByName struct {
	mock               *MerchRepo
	defaultExpectation *MerchRepoItemByNameExpectation
	expectations       []*MerchRepoItemByNameExpectation

	callArgs []*MerchRepoItemByNameParams
	mutex    sync.RWMutex
}

// MerchRepoItemByNameExpectation specifies expectation struct of the MerchRepo.ItemByName
type MerchRepoItemByNameExpectation struct {
	mock    *MerchRepo
	params  *MerchRepoItemByNameParams
	results *MerchRepoItemByNameResults
	Counter uint64
}

// MerchRepoItemByNameParams contains parameters of the MerchRepo.ItemByName
type MerchRepoItemByNameParams struct {
	ctx  context.Context
	name string
}

// MerchRepoItemByNameResults contains results of the MerchRepo.ItemByName
type MerchRepoItemByNameResults struct {
	m1  model.Merch
	err error
}

// Expect sets up expected params for MerchRepo.ItemByName
func (mmItemByName *mMerchRepoItemByName) Expect(ctx context.Context, name string) *mMerchRepoItemByName {
	if mmItemByName.mock.funcItemByName != nil {
		mmItemByName.mock.t.Fatalf("MerchRepo.ItemByName mock is already set by Set")
	}

	if mmItemByName.defaultExpectation == nil {
		mmItemByName.defaultExpectation = &MerchRepoItemByNameExpectation{}
	}

	mmItemByName.defaultExpectation.params = &MerchRepoItemByNameParams{ctx, name}
	for _, e := range mmItemByName.expectations {
		if minimock.Equal(e.params, mmItemByName.defaultExpectation.params) {
			mmItemByName.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmItemByName.defaultExpectation.params)
		}
	}

	return mmItemByName
}

// Inspect accepts an inspector function that has same arguments as the MerchRepo.ItemByName
func (mmItemByName *mMerchRepoItemByName) Inspect(f func(ctx context.Context, name string)) *mMerchRepoItemByName {
	if mmItemByName.mock.inspectFuncItemByName != nil {
		mmItemByName.mock.t.Fatalf("Inspect function is already set for MerchRepo.ItemByName")
	}

	mmItemByName.mock.inspectFuncItemByName = f

	return mmItemByName
}

// Return sets up results that will be returned by MerchRepo.ItemByName
func (mmItemByName *mMerchRepoItemByName) Return(m1 model.Merch, err error) *MerchRepo {
	if mmItemByName.mock.funcItemByName != nil {
		mmItemByName.mock.t.Fatalf("MerchRepo.ItemByName mock is already set by Set")
	}

	if mmItemByName.defaultExpectation == nil {
		mmItemByName.defaultExpectation = &MerchRepoItemByNameExpectation{mock: mmItemByName.mock}
	}
	mmItemByName.defaultExpectation.results = &MerchRepoItemByNameResults{m1, err}
	return mmItemByName.mock
}

// Set uses given function f to mock the MerchRepo.ItemByName method
func (mmItemByName *mMerchRepoItemByName) Set(f func(ctx context.Context, name string) (m1 model.Merch, err error)) *MerchRepo {
	if mmItemByName.defaultExpectation != nil {
		mmItemByName.mock.t.Fatalf("Default expectation is already set for the MerchRepo.ItemByName method")
	}

	if len(mmItemByName.expectations) > 0 {
		mmItemByName.mock.t.Fatalf("Some expectations are already set for the MerchRepo.ItemByName method")
	}

	mmItemByName.mock.funcItemByName = f
	return mmItemByName.mock
}

// When sets expectation for the MerchRepo.ItemByName which will trigger the result defined by the following
// Then helper
func (mmItemByName *mMerchRepoItemByName) When(ctx context.Context, name string) *MerchRepoItemByNameExpectation {
	if mmItemByName.mock.funcItemByName != nil {
		mmItemByName.mock.t.Fatalf("MerchRepo.ItemByName mock is already set by Set")
	}

	expectation := &MerchRepoItemByNameExpectation{
		mock:   mmItemByName.mock,
		params: &MerchRepoItemByNameParams{ctx, name},
	}
	mmItemByName.expectations = append(mmItemByName.expectations, expectation)
	return expectation
}

// Then sets up MerchRepo.ItemByName return parameters for the expectation previously defined by the When method
func (e *MerchRepoItemByNameExpectation) Then(m1 model.Merch, err error) *MerchRepo {
	e.results = &MerchRepoItemByNameResults{m1, err}
	return e.mock
}

// ItemByName implements service.MerchRepo
func (mmItemByName *MerchRepo) ItemByName(ctx context.Context, name string) (m1 model.Merch, err error) {
	mm_atomic.AddUint64(&mmItemByName.beforeItemByNameCounter, 1)
	defer mm_atomic.AddUint64(&mmItemByName.afterItemByNameCounter, 1)

	if mmItemByName.inspectFuncItemByName != nil {
		mmItemByName.inspectFuncItemByName(ctx, name)
	}

	mm_params := &MerchRepoItemByNameParams{ctx, name}

	// Record call args
	mmItemByName.ItemByNameMock.mutex.Lock()
	mmItemByName.ItemByNameMock.callArgs = append(mmItemByName.ItemByNameMock.callArgs, mm_params)
	mmItemByName.ItemByNameMock.mutex.Unlock()

	for _, e := range mmItemByName.ItemByNameMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.m1, e.results.err
		}
	}

	if mmItemByName.ItemByNameMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmItemByName.ItemByNameMock.defaultExpectation.Counter, 1)
		mm_want := mmItemByName.ItemByNameMock.defaultExpectation.params
		mm_got := MerchRepoItemByNameParams{ctx, name}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmItemByName.t.Errorf("MerchRepo.ItemByName got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmItemByName.ItemByNameMock.defaultExpectation.results
		if mm_results == nil {
			mmItemByName.t.Fatal("No results are set for the MerchRepo.ItemByName")
		}
		return (*mm_results).m1, (*mm_results).err
	}
	if mmItemByName.funcItemByName != nil {
		return mmItemByName.funcItemByName(ctx, name)
	}
	mmItemByName.t.Fatalf("Unexpected call to MerchRepo.ItemByName. %v %v", ctx, name)
	return
}

// ItemByNameAfterCounter returns a count of finished MerchRepo.ItemByName invocations
func (mmItemByName *MerchRepo) ItemByNameAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmItemByName.afterItemByNameCounter)
}

// ItemByNameBeforeCounter returns a count of MerchRepo.ItemByName invocations
func (mmItemByName *MerchRepo) ItemByNameBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmItemByName.beforeItemByNameCounter)
}

// Calls returns a list of arguments used in each call to MerchRepo.ItemByName.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmItemByName *mMerchRepoItemByName) Calls() []*MerchRepoItemByNameParams {
	mmItemByName.mutex.RLock()

	argCopy := make([]*MerchRepoItemByNameParams, len(mmItemByName.callArgs))
	copy(argCopy, mmItemByName.callArgs)

	mmItemByName.mutex.RUnlock()

	return argCopy
}

// MinimockItemByNameDone returns true if the count of the ItemByName invocations corresponds
// the number of defined expectations
func (m *MerchRepo) MinimockItemByNameDone() bool {
	for _, e := range m.ItemByNameMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ItemByNameMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterItemByNameCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcItemByName != nil && mm_atomic.LoadUint64(&m.afterItemByNameCounter) < 1 {
		return false
	}
	return true
}

// MinimockItemByNameInspect logs each unmet expectation
func (m *MerchRepo) MinimockItemByNameInspect() {
	for _, e := range m.ItemByNameMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to MerchRepo.ItemByName with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ItemByNameMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterItemByNameCounter) < 1 {
		if m.ItemByNameMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to MerchRepo.ItemByName")
		} else {
			m.t.Errorf("Expected call to MerchRepo.ItemByName with params: %#v", *m.ItemByNameMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcItemByName != nil && mm_atomic.LoadUint64(&m.afterItemByNameCounter) < 1 {
		m.t.Error("Expected call to MerchRepo.ItemByName")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *MerchRepo) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockGetAllItemsInspect()

		m.MinimockItemByNameInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *MerchRepo) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *MerchRepo) minimockDone() bool {
	done := true
	return done &&
		m.MinimockGetAllItemsDone() &&
		m.MinimockItemByNameDone()
}
